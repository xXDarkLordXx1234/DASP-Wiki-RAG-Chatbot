%META:TOPICINFO{author="NavidImani" date="1276782148" format="1.1" reprev="2" version="2"}%
%META:TOPICPARENT{name="StudentsList"}%
*Algorithm for Dictionary Alignments* 

Wordsense Matching: 

1. Extract the Wordsenses out of the dictionaries. 

2. Generate the correspondence graph with complete bipartite components only, each representing a word common in both dictionaries. 

3. Weight the edges according to a matching algorithms (e.g. lexico matching, common word count): w(e) 

4. Get rid of the weak correspondences as they would result in a bad matching. For every edge e if w(e)<&#949; get rid of the edges. 

where &#949; can be defined for each word according to some function depeding on how incoherent the wordsenses can be for that word. 

5. Calculate w'(e)=1-w(e)/MaxWeight 

6. Obtain a Minimum Weight Independent Dominating Set for each connected component in G based on the weights w'. 


A more general case of such matching can be defined based on the internal relations between wordsenses within a word. 
In theory, one can assume a general structure for the graph generated by each word in a dictionary, 
although in real life situations the presence of cycles would be an indication of inconsistency in the semantics defining the relations. 

In order to obtain a matching for the wordsenses of two dictionaries when relations are existence, one may proceed as follows: 

Wordsense Matching With relations (Input: G , H constructed from wordsense nodes with relation edges added) 

a) generate the weights as before for each pair of vertices for each pair of vertices in GxH. 

b) Let c_u(v) denote the cost of mapping a wordsense v from G to a wordsense u in H. Then c_u(v)=1- w(e) for e=(u,v). 

c) As the relations can be defined in different grainulity levels, we need to allow the mapping of two wordsenses with a relation edge 
into a wordsense in the other dictionary to overcome this difficulty, we G and H reflexive by adding one self-loop edge for every vertex in G and H. 

d) Perform a Minimum Cost Homomorphism between the two graphs using the cost function c. 

e) The general result for the Homomorphism problem implies that the algorithm is polytime if H is in the family of interval graphs (e.g. a simple path). See [1].

*References* 

[1]    G. Gutin, P. Hell, A. Rafiey, A. Yeo, 'A Dichotomy for Minimum Cost Graph Homomorphism', In European Journal of Combinatorics - EJC , pages 900-911, 2008.